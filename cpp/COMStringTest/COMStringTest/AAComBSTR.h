//------------------------------------------------------------------------------
// Copyright (C) 2012 Invensys Systems Inc.  All rights reserved.
// 
// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//------------------------------------------------------------------------------

#pragma once

/*WW:
AAComBSTR is designed to be a safer replacement for CComBSTR.

Using AAComBSTR
---------------

How to add to source file:
 Add the following lines to each source file that needs to use AAComBSTR.
 Or, add them to stdafx.h, but be sure to add the header file generated by your
 project IDL before these lines:

     #include "\DevStore\Logger\ExtInterfaces\FsLogger.h"
     #include <ClassUtilities\AAComBSTR.h>

 And then at the top of one of your .cpp files, such as the file that contains
 your DllMain() or WinMain() function, add:
 
     IMPLEMENT_LOGGER_GLOBALS;



Differences from CComBSTR
-------------------------

operator &() reports possible memory leaks by logging errors
  AAComBSTR logs an error if opeator&() is called and the string is not empty.
  CComBSTR doesn't free itself and leaks memory if operator & is used after 
  the string has been initialized.

Detach() replaced with DetachTo()
  Detach() has been removed and replaced with the safer
  DetachTo(BSTR*) method.  This prevents clients from detaching 
  into thin air and leaking memory.  DetachTo() will log an 
  error if the target string isn't empty (NULL).

Copy() removed from public interface, replaced with CopyTo()
  Copy() had the same problem as Detach() above.

operator+= throws exception if out of memory
  Microsoft updated this in their CComBSTR in VS7, AAComBSTR matches VS7

Constructor with int should be replaced with static GetSizedAAComBSTR() method
  Integer overloaded constructor was confusing, it looked like it would convert a number
  to a string.  This caused bugs.  Replaced with explicit, static methods that can be used 
  in place of constructors.


 Make operator!=() compare strings instead of pointers
    Microsoft updated this in their CComBSTR in VS7, AAComBSTR matches VS7

Throws errors as defined by ComError.h instead of AtlThrow

Removed BSTRToArray()
    This method is barely documented and error prone.  Clients can use 
    VectorFromBstr() instead.

Removed ArrayToBSTR()
    This method is barely documented and error prone.  Clients can use 
    BstrFromVector() instead.

ReadFromStream() won't fail if stream isn't empty
    Read from string will simply overwrite any existing string.


Rejected Suggestions
--------------------
Change behavior of == and < for multi-part BSTRS

    Suggestion:
        One of the lack of CComBSTR is a 'confusing' (I would say, 
        completely misleading) comparison implementation:

        1) operator <
        2) operator ==

        In most cases it works fine while a developer 
        uses CComBSTR to keep regular C-style strings. 

        Once you want to keep a real BSTR containing embedded 
        NULL's you got a problem with comparison.

        ...
        CComBSTR bstrLong( 64, L"abc\000 this is a long string" );
        CComBSTR bstrShort( 24, L"abc\000 a short string" );
        bool bEqual = ( bstrLong == bstrShort ); // misleading comparison 
                                                 // returns true!
        ...

    Reason:
        We want AAComBSTR to be a direct replacement for CComBSTR such 
        that changes in the contact will be obvious to the user.  If 
        we change the behavior of <, ==, then it will be change the 
        behavior of our code in not so obvious ways.  It would be a 
        good idea the new class was for new code only.

operator=() should not make a copy, instead it should act more like Attach()

    Suggestion:
        operator=() should not make a copy, instead it should act more like Attach()

    Reason:
        Breaks copy contract usually assumed by operator=(). Breaks existing code.




Pending Changes
---------------
Support EqualsIgnoreCase()

Support FormatString() similar to C#

*/

class AAComBSTR
{
private:
    //WW: made private to prevent memory leaks, use CopyTo() instaed
    BSTR Copy() const
	{
		if (m_str == NULL)
			return NULL;
        UINT    size = ::SysStringByteLen(m_str);
        BSTR bstr = ::SysAllocStringByteLen((char*)m_str, size);
        if( bstr == NULL )
		{
            throw E_OUTOFMEMORY; // to shutup klockwork
		}
        return bstr;
	}
    //WW: made private to prevent misuse, use static method GetSizedAAComBSTR instead
	AAComBSTR(int nSize)
	{
		if (nSize == 0)
			m_str = NULL;
		else
		{
			m_str = ::SysAllocStringLen(NULL, nSize);
			if (m_str == NULL)
			{
				throw E_OUTOFMEMORY; // to shutup klockwork
			}
		}
	}
    //WW: made private to prevent misuse, use static method GetSizedAAComBSTR instead
	AAComBSTR(int nSize, LPCOLESTR sz)
	{
		if (nSize == 0)
			m_str = NULL;
		else
		{
			m_str = ::SysAllocStringLen(sz, nSize);
			if (m_str == NULL)
			{
				throw E_OUTOFMEMORY; // to shutup klockwork
			}
		}
	}
public:
    static AAComBSTR GetSizedAAComBSTR(int nSize)
    {
        return AAComBSTR(nSize);
    }
    static AAComBSTR GetSizedAAComBSTR(int nSize, LPCOLESTR sz)
    {
        return AAComBSTR(nSize, sz);
    }
	BSTR m_str;
	AAComBSTR() throw()
	{
		m_str = NULL;
	}
	AAComBSTR(LPCOLESTR pSrc)
	{
		if (pSrc == NULL)
			m_str = NULL;
		else
		{
			m_str = ::SysAllocString(pSrc);
			if (m_str == NULL)
			{
				throw E_OUTOFMEMORY; // to shutup klockwork
			}
		}
	}
	AAComBSTR(const AAComBSTR& src)
	{
		m_str = src.Copy();
	}
	AAComBSTR(REFGUID guid)
	{
		OLECHAR szGUID[64];
		::StringFromGUID2(guid, szGUID, 64);
		m_str = ::SysAllocString(szGUID);
		if (m_str == NULL)
		{
			throw E_OUTOFMEMORY; // to shutup klockwork
		}
	}
	AAComBSTR& operator=(const AAComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}
	AAComBSTR& operator=(LPCOLESTR pSrc)
	{
		if (pSrc != m_str)
		{
			::SysFreeString(m_str);
			if (pSrc != NULL)
			{
				m_str = ::SysAllocString(pSrc);
				if (m_str == NULL)
				{
					throw E_OUTOFMEMORY; // to shutup klockwork
				}
			}
			else
				m_str = NULL;
		}
		return *this;
	}
	~AAComBSTR() throw()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const throw()
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	unsigned int ByteLength() const throw()
	{
		return (m_str == NULL)? 0 : SysStringByteLen(m_str);
	}
	operator BSTR() const throw()
	{
		return m_str;
	}
	BSTR* operator&() throw()
	{
        if( m_str != NULL )
        {

//			CMinidump	minidump;
//			CComBSTR	bstrDumpfile;
//			bool		bFileCreated = false;
//
//			minidump.DumpWithoutException(&bstrDumpfile, &bFileCreated);
//			if (bFileCreated)
//			{
//				LogWarning(L"Minidump is generated as %s.", bstrDumpfile);
//			}
        }
		return &m_str;
	}
	void CopyTo(BSTR* pbstr)
	{
        //WW: must pass a pointer
        if( pbstr == 0 )
        {
            throw E_POINTER; // to shutup klocwork
        }

        //WW: BSTR must be empty
        if( * pbstr != 0 )
        {

//			CMinidump	minidump;
//			CComBSTR	bstrDumpfile;
//			bool		bFileCreated = false;
//
//			minidump.DumpWithoutException(&bstrDumpfile, &bFileCreated);
//			if (bFileCreated)
//			{
//				LogWarning(L"Minidump is generated as %s.", bstrDumpfile);
//			}
        }

		*pbstr = Copy();
	}
	//WW: copy BSTR to VARIANT
	void CopyTo(VARIANT *pvarDest)
	{
        if( pvarDest == NULL )
        {
            throw E_POINTER; // to shutup klocwork
        }

		pvarDest->vt = VT_BSTR;
		pvarDest->bstrVal = Copy();
	}
	void Attach(BSTR src) throw()
	{
		if (m_str != src)
		{
			::SysFreeString(m_str);
			m_str = src;
		}
	}
    void DetachTo( BSTR * bstr )
    {
        //WW: must pass a pointer
        if( bstr == 0 )
        {
            throw E_POINTER; // to shutup klocwork
        }

        //WW: BSTR must be empty
        if( * bstr != 0 )
        {

//			CMinidump	minidump;
//			CComBSTR	bstrDumpfile;
//			bool		bFileCreated = false;
//
//			minidump.DumpWithoutException(&bstrDumpfile, &bFileCreated);
//			if (bFileCreated)
//			{
//				LogWarning(L"Minidump is generated as %s.", bstrDumpfile);
//			}
        }

        * bstr = m_str;
        m_str = NULL;
    }
    void DetachTo( VARIANT * pvarDest )
    {
        if( pvarDest == NULL )
        {
            throw E_POINTER; // to shutup klocwork
        }

		pvarDest->vt = VT_BSTR;
		pvarDest->bstrVal = m_str;
        m_str = NULL;
    }
	void Empty() throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const throw()
	{
		return (m_str == NULL);
	}
	void Append(const AAComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
	}
	void Append(LPCOLESTR lpsz)
	{
		Append(lpsz, UINT(ocslen(lpsz)));
	}
	// a BSTR is just an LPOLESTR so we need a special version to signify
	// that we are appending a BSTR
	void AppendBSTR(BSTR p)
	{
		if (p == NULL)
			return;
		BSTR bstrNew = NULL;
		HRESULT hr = VarBstrCat(m_str, p, &bstrNew);
        if( FAILED(hr ) )
        {
            throw hr; // to shutup klocwork
        }

		::SysFreeString(m_str);
		m_str = bstrNew;
	}
	void Append(LPCOLESTR lpsz, int nLen)
	{
		if (lpsz == NULL || (m_str != NULL && nLen == 0))
			return;
		int n1 = Length();
		BSTR b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
        {
            throw E_OUTOFMEMORY; // to shutup klocwork
        }
		memcpy_s(b, (n1+nLen)*sizeof(OLECHAR), m_str, n1*sizeof(OLECHAR));
        //WW: correct possible buffer over-read where nLen > strlen(lpsz)
        //original: memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
        wcsncpy_s(b+n1, nLen+1, lpsz, nLen); 
		
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
	}
	void Append(char ch)
	{
		OLECHAR chO = ch;

		Append( &chO, 1 );
	}
	void Append(wchar_t ch)
	{
		Append( &ch, 1 );
	}
	void AppendBytes(const char* lpsz, int nLen)
	{
		if (lpsz == NULL || nLen == 0)
			return;
		int n1 = ByteLength();
		BSTR b;
		b = ::SysAllocStringByteLen(NULL, n1+nLen);
		if (b == NULL)
        {
            throw E_OUTOFMEMORY; // to shutup klocwork
        }
		memcpy_s(b, n1+nLen, m_str, n1);
		memcpy_s(((char*)b)+n1, nLen, lpsz, nLen);
		*((OLECHAR*)(((char*)b)+n1+nLen)) = NULL;
		SysFreeString(m_str);
		m_str = b;
	}
	void AssignBSTR(const BSTR bstrSrc)
	{
        if( m_str == bstrSrc )
            return;
		::SysFreeString(m_str);
		if (bstrSrc != NULL)
		{
			m_str = ::SysAllocStringByteLen((char*)bstrSrc, ::SysStringByteLen(bstrSrc));
			if (m_str == NULL)
            {
                throw E_OUTOFMEMORY; // to shutup klocwork
            }
		}
		else
			m_str = NULL;
	}
	void ToLower() throw()
	{
		if (m_str != NULL)
		{
			// Convert in place
			CharLowerBuffW(m_str, Length());
		}
	}
	void ToUpper() throw()
	{
		if (m_str != NULL)
		{
			// Convert in place
			CharUpperBuffW(m_str, Length());
		}
	}
	AAComBSTR& operator+=(const AAComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	AAComBSTR& operator+=(LPCOLESTR pszSrc)
	{
		Append(pszSrc);
		return *this;
	}
	bool operator<(const AAComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_LT;
	}
	bool operator<(LPCOLESTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator<(bstr2);
	}
	bool operator>(const AAComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_GT;
	}
	bool operator>(LPCOLESTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator>(bstr2);
	}

	bool operator!=(const AAComBSTR& bstrSrc) const throw()
	{
		return !operator==(bstrSrc);
	}
	bool operator!=(LPCOLESTR pszSrc) const
	{
		return !operator==(pszSrc);
	}
	bool operator!=(int nNull) const throw()
	{
		return !operator==(nNull);
	}

	bool operator==(const AAComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_EQ;
	}
	bool operator==(LPCOLESTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator==(bstr2);
	}
    //WW: added this to work in VS.NET 2003
    bool operator==(LPOLESTR pszSrc) const
    {
        return operator==((LPCOLESTR) pszSrc);
    }

	bool operator==(int nNull) const throw()
	{
		ATLASSERT(nNull == NULL);
		(void)nNull;
		return (m_str == NULL);
	}
	AAComBSTR(LPCSTR pSrc)
	{
		if (pSrc != NULL)
		{
			m_str = A2WBSTR(pSrc);  
			if (m_str == NULL)
            {
                throw E_OUTOFMEMORY; // to shutup klocwork
            }
		}
		else
			m_str = NULL;
	}

	void Append(LPCSTR lpsz) throw()
	{
		if (lpsz == NULL)
			return;

		AAComBSTR bstrTemp = lpsz;
		Append(bstrTemp);
	}
	AAComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		if (m_str == NULL && pSrc != NULL)
        {
            throw E_OUTOFMEMORY; // to shutup klocwork
        }
		return *this;
	}
	bool operator<(LPCSTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator<(bstr2);
	}
	bool operator>(LPCSTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator>(bstr2);
	}
	bool operator!=(LPCSTR pszSrc) const
	{
		return !operator==(pszSrc);
	}
	bool operator==(LPCSTR pszSrc) const
	{
		AAComBSTR bstr2(pszSrc);
		return operator==(bstr2);
	}
	void WriteToStream(IStream* pStream)
	{
        if( pStream == NULL )
        {
            throw E_INVALIDARG; // to shutup klocwork
        }
		ULONG cb;
		ULONG cbStrLen = ULONG(m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0);
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			throw hr;
        hr = cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
        if( FAILED( hr ) )
            throw E_INVALIDARG ;
	}
	void ReadFromStream(IStream* pStream)
	{
        if( pStream == NULL )
        {
            throw E_INVALIDARG; // to shutup klocwork
        }

        Empty();

		ULONG cbStrLen = 0;
        ULONG bytesRead = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), &bytesRead);
        if( bytesRead != sizeof(cbStrLen) )
        {
            throw E_FAIL; // to shutup klocwork
        }

        if( hr != S_OK )
        {
            throw hr; // to shutup klocwork
        }

        // empty string?
        if( cbStrLen == 0 )
            return;

		//subtract size for terminating NULL which we wrote out
		//since SysAllocStringByteLen overallocates for the NULL
		m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
		if (m_str == NULL)
        {
			hr = E_OUTOFMEMORY;
            throw E_OUTOFMEMORY; // to shutup klocwork
        }
		else
			hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		// If SysAllocStringByteLen or IStream::Read failed, reset seek 
		// pointer to start of BSTR size.
		if (hr != S_OK)
		{
			LARGE_INTEGER nOffset;
			nOffset.QuadPart = -(static_cast<LONGLONG>(sizeof(cbStrLen)));
			pStream->Seek(nOffset, STREAM_SEEK_CUR, NULL);
		}

		if (hr == S_FALSE)
        {
            throw E_FAIL; // to shutup klocwork
        }
        if( FAILED( hr) )
        {
            throw hr; // to shutup klocwork
        }
	}
#ifdef ATLSTRINGRESOURCEIMAGE
	static bool LoadStringResource(HINSTANCE hInstance, UINT uID, BSTR& bstrText) throw()
	{
		const ATLSTRINGRESOURCEIMAGE* pImage;

		ATLASSERT(bstrText == NULL);

		pImage = AtlGetStringResourceImage(hInstance, uID);
		if (pImage != NULL)
		{
			bstrText = ::SysAllocStringLen(pImage->achString, pImage->nLength);
		}

		return (bstrText != NULL) ? true : false;
	}
	static bool LoadStringResource(UINT uID, BSTR& bstrText) throw()
	{
		const ATLSTRINGRESOURCEIMAGE* pImage;

		ATLASSERT(bstrText == NULL);

		pImage = AtlGetStringResourceImage(uID);
		if (pImage != NULL)
		{
			bstrText = ::SysAllocStringLen(pImage->achString, pImage->nLength);
		}

		return (bstrText != NULL) ? true : false;
	}
    bool LoadString(HINSTANCE hInst, UINT nID) throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
		return LoadStringResource(hInst, nID, m_str);
	}
	bool LoadString(UINT nID) throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
		return LoadStringResource(nID, m_str);
	}
#else
    bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}
#endif
};

//WW: Ensure that AAComBSTR can be used in place of LPCWSTR 
//    in printf like statements that rely on the size of the 
//    parameter.
C_ASSERT( sizeof(AAComBSTR) == sizeof(LPCWSTR) );