#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define DEBUGGING 1
#include "tracer.h"

#define ON  1
#define OFF 0


#define THE_MEMORY_SZ 512
                           /*  nmemonic form      word1 word2 word3  */
                           /*  ------------------------------------- */
#define ABORT          0    /*     ???             ???                */
#define ADDR_TO_A      1    /*  move [ADDR] -> A   CMD   ADDR   -     */
#define A_TO_ADDR      2    /*  move A -> [ADDR]   CMD   ADDR   -     */
#define ADDR_TO_B      3    /*  move [ADDR] -> B   CMD   ADDR   -     */
#define B_TO_ADDR      4    /*  move B -> [ADDR]   CMD   ADDR   -     */
#define ADDR_TO_C      5    /*  move [ADDR] -> C   CMD   ADDR   -     */
#define C_TO_ADDR      6    /*  move C -> [ADDR]   CMD   ADDR   -     */
#define ADDR_TO_D      7    /*  move [ADDR] -> D   CMD   ADDR   -     */
#define D_TO_ADDR      8    /*  move D -> [ADDR]   CMD   ADDR   -     */
#define A_PLUS_B_TO_C  9    /*  A + B -> C         CMD   -      -     */
#define A_PLUS_C_TO_B  10   /*  A + C -> B         CMD   -      -     */
#define C_PLUS_B_TO_A  11   /*  C + B -> A         CMD   -      -     */
#define NUMBER_TO_A    12   /*  move #NUM -> A     CMD   NUM    -     */
#define NUMBER_TO_B    13   /*  move #NUM -> B     CMD   NUM    -     */
#define NUMBER_TO_C    14   /*  move #NUM -> C     CMD   NUM    -     */
#define NUMBER_TO_D    15   /*  move #NUM -> D     CMD   NUM    -     */
#define JUMP_TO_ADDR   16   /*  jump ADDR          CMD   ADDR   -     */
#define CALL           17   /*  call ADDR          CMD   ADDR   -     */
#define RETURN         18   /*  return             CMD   -      -     */
#define CMP_A_B        19   /*  compare A,B        CMD   -      -     */
#define CMP_A_C        20   /*  compare A,C        CMD   -      -     */
#define BRANCH_LSS     21   /*  brlss              CMD   ADDR   -     */
#define BRANCH_GTR     22   /*  brgtr              CMD   ADDR   -     */
#define BRANCH_EQL     23   /*  breql              CMD   ADDR   -     */
#define BRANCH_LEQ     24   /*  brleq              CMD   ADDR   -     */
#define BRANCH_GEQ     25   /*  brgeq              CMD   ADDR   -     */
#define A_MINUS_B_TO_C 26   /*  A - B -> C         CMD   -      -     */
#define A_MINUS_C_TO_B 27   /*  A - C -> B         CMD   -      -     */
#define C_MINUS_B_TO_A 28   /*  C - B -> A         CMD   -      -     */
#define A_TO_ADDRINB   29   /*  move A -> [B]      CMD   -      -     */
#define ADDRINB_TO_A   30   /*  move [B] -> A      CMD   -      -     */
#define SWAP_A_B       31   /*  swap A <-> B       CMD   -      -     */
#define SWAP_A_C       32   /*  swap A <-> C       CMD   -      -     */
#define SWAP_A_D       33   /*  swap A <-> D       CMD   -      -     */
#define SWAP_B_C       34   /*  swap B <-> C       CMD   -      -     */
#define SWAP_B_D       35   /*  swap B <-> D       CMD   -      -     */
#define SWAP_C_D       36   /*  swap C <-> D       CMD   -      -     */



#define BAD_CMD_FETCH 1
#define ADDRESS_INCREMENT 60
/*
	proc1.c
	generated by Look & Feel version 3.2 from proc1.lnf
	03/31/92
*/

#include <stdio.h>
#include "cscape.h"
#include "teddecl.h"
#include "msys.h"
#include "sled.h"

sed_type 
   proc1_sed;
boolean 
   mouse_on;
int 
   addr_inc;

int proc1(addr1, 
          addr2, 
          addr3, 
          addr4, 
          addr5, 
          addr6, 
          pos, 
          reg_a, 
          reg_b, 
          reg_c, 
          reg_d, 
          reg_ip, 
          reg_tar, 
          last_cmd,
          reg_carryf,
          reg_zerof   )
	int *addr1;
	int *addr2;
	int *addr3;
	int *addr4;
	int *addr5;
	int *addr6;
	int *pos;
	int *reg_a;
	int *reg_b;
	int *reg_c;
	int *reg_d;
	int *reg_ip;
	int *reg_tar;
   char *last_cmd;
   int  *reg_carryf;
   int  *reg_zerof;
{
	menu_type	menu;
	int 		ret;

	menu = menu_Open();

	menu_Printf(menu, "@[47, ]Registers\n    :@[44, ]A:\n    :@[44, ]B:\n    :@[44, ]C:\n    :@[44, ]D:\n    :");
                                                         /*5555555 */
                                                         /*0123456 */
	menu_Printf(menu, "@[43, ]IP:\n    :@[42, ]TAR:\n@[49, ]C:   Z:");
	menu_Printf(menu, "@p[1,0]@f{addr1}p[### ]",
	  addr1, &sint_funcs);
	menu_Printf(menu, "@p[2,0]@f{addr2}p[### ]",
	  addr2, &sint_funcs);
	menu_Printf(menu, "@p[3,0]@f{addr3}p[### ]",
	  addr3, &sint_funcs);
	menu_Printf(menu, "@p[4,0]@f{addr4}p[### ]",
	  addr4, &sint_funcs);
	menu_Printf(menu, "@p[5,0]@f{addr5}p[### ]",
	  addr5, &sint_funcs);
	menu_Printf(menu, "@p[6,0]@f{addr6}p[### ]",
	  addr6, &sint_funcs);
	menu_Printf(menu, "@p[1,7]@f{pos00}[### ]",
	  &(pos[0]), &sint_funcs);
	menu_Printf(menu, "@p[1,11]@f{pos01}[### ]",
	  &(pos[01]), &sint_funcs);
	menu_Printf(menu, "@p[1,15]@f{pos02}[### ]",
	  &(pos[02]), &sint_funcs);
	menu_Printf(menu, "@p[1,19]@f{pos03}[### ]",
	  &(pos[03]), &sint_funcs);
	menu_Printf(menu, "@p[1,23]@f{pos04}[### ]",
	  &(pos[04]), &sint_funcs);
	menu_Printf(menu, "@p[1,27]@f{pos05}[### ]",
	  &(pos[05]), &sint_funcs);
	menu_Printf(menu, "@p[1,31]@f{pos06}[### ]",
	  &(pos[06]), &sint_funcs);
	menu_Printf(menu, "@p[1,35]@f{pos07}[### ]",
	  &(pos[07]), &sint_funcs);
	menu_Printf(menu, "@p[1,39]@f{pos08}[### ]",
	  &(pos[8]), &sint_funcs);
	menu_Printf(menu, "@p[1,43]@f{pos09}[### ]",
	  &(pos[9]), &sint_funcs);
	menu_Printf(menu, "@p[2,7]@f{pos10}[### ]",
	  &(pos[10]), &sint_funcs);
	menu_Printf(menu, "@p[2,11]@f{pos11}[### ]",
	  &(pos[11]), &sint_funcs);
	menu_Printf(menu, "@p[2,15]@f{pos12}[### ]",
	  &(pos[12]), &sint_funcs);
	menu_Printf(menu, "@p[2,19]@f{pos13}[### ]",
	  &(pos[13]), &sint_funcs);
	menu_Printf(menu, "@p[2,23]@f{pos14}[### ]",
	  &(pos[14]), &sint_funcs);
	menu_Printf(menu, "@p[2,27]@f{pos15}[### ]",
	  &(pos[15]), &sint_funcs);
	menu_Printf(menu, "@p[2,31]@f{pos16}[### ]",
	  &(pos[16]), &sint_funcs);
	menu_Printf(menu, "@p[2,35]@f{pos17}[### ]",
	  &(pos[17]), &sint_funcs);
	menu_Printf(menu, "@p[2,39]@f{pos18}[### ]",
	  &(pos[18]), &sint_funcs);
	menu_Printf(menu, "@p[2,43]@f{pos19}[### ]",
	  &(pos[19]), &sint_funcs);
	menu_Printf(menu, "@p[3,7]@f{pos20}[### ]",
	  &(pos[20]), &sint_funcs);
	menu_Printf(menu, "@p[3,11]@f{pos21}[### ]",
	  &(pos[21]), &sint_funcs);
	menu_Printf(menu, "@p[3,15]@f{pos22}[### ]",
	  &(pos[22]), &sint_funcs);
	menu_Printf(menu, "@p[3,19]@f{pos23}[### ]",
	  &(pos[23]), &sint_funcs);
	menu_Printf(menu, "@p[3,23]@f{pos24}[### ]",
	  &(pos[24]), &sint_funcs);
	menu_Printf(menu, "@p[3,27]@f{pos25}[### ]",
	  &(pos[25]), &sint_funcs);
	menu_Printf(menu, "@p[3,31]@f{pos26}[### ]",
	  &(pos[26]), &sint_funcs);
	menu_Printf(menu, "@p[3,35]@f{pos27}[### ]",
	  &(pos[27]), &sint_funcs);
	menu_Printf(menu, "@p[3,39]@f{pos28}[### ]",
	  &(pos[28]), &sint_funcs);
	menu_Printf(menu, "@p[3,43]@f{pos29}[### ]",
	  &(pos[29]), &sint_funcs);
	menu_Printf(menu, "@p[4,7]@f{pos30}[### ]",
	  &(pos[30]), &sint_funcs);
	menu_Printf(menu, "@p[4,11]@f{pos31}[### ]",
	  &(pos[31]), &sint_funcs);
	menu_Printf(menu, "@p[4,15]@f{pos32}[### ]",
	  &(pos[32]), &sint_funcs);
	menu_Printf(menu, "@p[4,19]@f{pos33}[### ]",
	  &(pos[33]), &sint_funcs);
	menu_Printf(menu, "@p[4,23]@f{pos34}[### ]",
	  &(pos[34]), &sint_funcs);
	menu_Printf(menu, "@p[4,27]@f{pos35}[### ]",
	  &(pos[35]), &sint_funcs);
	menu_Printf(menu, "@p[4,31]@f{pos36}[### ]",
	  &(pos[36]), &sint_funcs);
	menu_Printf(menu, "@p[4,35]@f{pos37}[### ]",
	  &(pos[37]), &sint_funcs);
	menu_Printf(menu, "@p[4,39]@f{pos38}[### ]",
	  &(pos[38]), &sint_funcs);
	menu_Printf(menu, "@p[4,43]@f{pos39}[### ]",
	  &(pos[39]), &sint_funcs);
	menu_Printf(menu, "@p[5,7]@f{pos40}[### ]",
	  &(pos[40]), &sint_funcs);
	menu_Printf(menu, "@p[5,11]@f{pos41}[### ]",
	  &(pos[41]), &sint_funcs);
	menu_Printf(menu, "@p[5,15]@f{pos42}[### ]",
	  &(pos[42]), &sint_funcs);
	menu_Printf(menu, "@p[5,19]@f{pos43}[### ]",
	  &(pos[43]), &sint_funcs);
	menu_Printf(menu, "@p[5,23]@f{pos44}[### ]",
	  &(pos[44]), &sint_funcs);
	menu_Printf(menu, "@p[5,27]@f{pos45}[### ]",
	  &(pos[45]), &sint_funcs);
	menu_Printf(menu, "@p[5,31]@f{pos46}[### ]",
	  &(pos[46]), &sint_funcs);
	menu_Printf(menu, "@p[5,35]@f{pos47}[### ]",
	  &(pos[47]), &sint_funcs);
	menu_Printf(menu, "@p[5,39]@f{pos48}[### ]",
	  &(pos[48]), &sint_funcs);
	menu_Printf(menu, "@p[5,43]@f{pos49}[### ]",
	  &(pos[49]), &sint_funcs);
	menu_Printf(menu, "@p[6,7]@f{pos50}[### ]",
	  &(pos[50]), &sint_funcs);
	menu_Printf(menu, "@p[6,11]@f{pos51}[### ]",
	  &(pos[51]), &sint_funcs);
	menu_Printf(menu, "@p[6,15]@f{pos52}[### ]",
	  &(pos[52]), &sint_funcs);
	menu_Printf(menu, "@p[6,19]@f{pos53}[### ]",
	  &(pos[53]), &sint_funcs);
	menu_Printf(menu, "@p[6,23]@f{pos54}[### ]",
	  &(pos[54]), &sint_funcs);
	menu_Printf(menu, "@p[6,27]@f{pos55}[### ]",
	  &(pos[55]), &sint_funcs);
	menu_Printf(menu, "@p[6,31]@f{pos56}[### ]",
	  &(pos[56]), &sint_funcs);
	menu_Printf(menu, "@p[6,35]@f{pos57}[### ]",
	  &(pos[57]), &sint_funcs);
	menu_Printf(menu, "@p[6,39]@f{pos58}[### ]",
	  &(pos[58]), &sint_funcs);
	menu_Printf(menu, "@p[6,43]@f{pos59}[### ]",
	  &(pos[59]), &sint_funcs);
	menu_Printf(menu, "@p[1,53]@f{reg_a}p[##### ]",
	  reg_a, &int_funcs);
	menu_Printf(menu, "@p[2,53]@f{reg_b}p[##### ]",
	  reg_b, &int_funcs);
	menu_Printf(menu, "@p[3,53]@f{reg_c}p[##### ]",
	  reg_c, &int_funcs);
	menu_Printf(menu, "@p[4,53]@f{reg_d}p[##### ]",
	  reg_d, &int_funcs);
	menu_Printf(menu, "@p[5,53]@f{reg_ip}p[##### ]",
	  reg_ip, &int_funcs);    
	menu_Printf(menu, "@p[6,53]@f{reg_tar}p[##### ]",
	  reg_tar, &int_funcs);
	menu_Printf(menu, "@p[7,52]@fp[#]",
	  reg_carryf, &int_funcs);
	menu_Printf(menu, "@p[7,57]@fp[#]",
	  reg_zerof, &int_funcs);
   menu_Printf(menu, "@p[11,7]@fp[########################################]",
    last_cmd, &string_funcs);
	menu_Printf(menu, "@p[8,7]@fd2[Page Down]",
	  NULL, &gmenu_funcs,NULL,"200");
	menu_Printf(menu, "@p[8,18]@fd2[Page Up]",
	  NULL, &gmenu_funcs,NULL,"201");
	menu_Printf(menu, "@p[8,27]@fd2[Single Step]",
	  NULL, &gmenu_funcs,NULL,"202");
	menu_Printf(menu, "@p[10,7]@fd2[End]",
	  NULL, &gmenu_funcs,NULL,"203");
	menu_Printf(menu, "@p[10,18]@fd2[Reset IP]",
	  NULL, &gmenu_funcs,NULL,"204");
	menu_Flush(menu);

	proc1_sed = sed_Open(menu);
	sed_SetColors(proc1_sed, 0x07, 0x07, 0x70);

	sed_SetBorder(proc1_sed, bd_prompt);
	sed_SetBorderTitle(proc1_sed, "Processor Window");
	sed_SetPosition(proc1_sed, 5, 5);
	sed_SetHeight(proc1_sed, 13);
	sed_SetWidth(proc1_sed, 70);
 	/* Attach a mouse handler to the sed */
   if (mouse_on)
      sed_SetMouse(proc1_sed, sedmou_Click);


	return(ret);
}


#define GO_DOWN     200
#define GO_UP       201
#define SINGLE_STEP 202
#define END_PROG    203
#define RESET_IP    204
unsigned int ss_processor(void);


unsigned int x;
unsigned int a,
             b,
             c,
             d,
             ip,   /* instruction pointer       */
             tar;  /* temporary address pointer */
unsigned int carryf,
             zerof;
  
unsigned char cmd_msg[40];
#define RETURN_STACK_SZ 100

unsigned int the_memory[THE_MEMORY_SZ];
unsigned int screen_buf[ADDRESS_INCREMENT];
unsigned int return_stack[RETURN_STACK_SZ];
unsigned int return_stack_top = 0;
main()
   {
   boolean
      done;
   char
      next_address,
      prev_address,
      ss,
      end;

   int 
      addr1,
      addr2,
      addr3,
      addr4,
      addr5,
      addr6,
      ret_code;
#ifdef DEBUGGING
   if ((trcfile = fopen("tracer.trc", "w")) == NULL) 
      {
      printf("Can't open PC file");
      exit(0);
      }
   else 
      {
#endif

      ip = 0; /* set up instruction pointer to be 0 */
      for ( x = 0 ; x < THE_MEMORY_SZ ; x++)
         {
         the_memory[x] = 0;
         }
      /* test code 
      the_memory[0]  = NUMBER_TO_A    ;
      the_memory[1]  = 10             ;
      the_memory[2]  = A_TO_ADDR      ;
      the_memory[3]  = 40             ;
      the_memory[4]  = NUMBER_TO_A    ;
      the_memory[5]  = 22             ;
      the_memory[6]  = A_TO_ADDR      ;
      the_memory[7]  = 41             ;
      the_memory[8]  = ADDR_TO_A      ;
      the_memory[9]  = 40             ;
      the_memory[10] = ADDR_TO_B      ;
      the_memory[11] = 41             ;
      the_memory[12] = A_PLUS_B_TO_C  ;
      the_memory[13] = C_TO_ADDR      ;
      the_memory[14] = 42             ;
      the_memory[15] = JUMP_TO_ADDR   ;
      the_memory[16] = 60             ;

      the_memory[60] = ADDR_TO_D      ;
      the_memory[61] = 42             ;
*/
      disp_Init(def_ModeText, NULL);
      if (!hard_InitMouse()) 
         {
         mouse_on = FALSE;
         }
      else
         {
         mouse_on = TRUE;
         sedwin_ClassInit();
         }

      addr1 = 0  ;
      addr2 = 10 ;
      addr3 = 20 ;
      addr4 = 30 ;
      addr5 = 40 ;
      addr6 = 50 ;
      done=FALSE;
      addr_inc = 0;
      carryf=0;
      zerof=0;
      proc1(&addr1, 
            &addr2, 
            &addr3, 
            &addr4, 
            &addr5, 
            &addr6, 
            (int *) screen_buf, 
            &a, 
            &b, 
            &c, 
            &d, 
            &ip, 
            &tar, 
            (char *)cmd_msg,
            &carryf,
            &zerof            );
      while (!done)
         {
         memcpy(screen_buf,&(the_memory[addr_inc]),120);
	      sed_Repaint(proc1_sed);
         sed_GotoField(proc1_sed,sed_GetFieldNo(proc1_sed));
         ret_code = sed_Go(proc1_sed);
         memcpy(&(the_memory[addr_inc]),screen_buf,120);
         switch(ret_code)
            {
            case GO_DOWN    :
               if( (addr_inc + (ADDRESS_INCREMENT *2)) < THE_MEMORY_SZ )
                  {
                  TRACE_STR("incrementing address");
                  addr_inc = addr_inc + ADDRESS_INCREMENT;
                  addr1 = addr_inc;
                  addr2 = addr_inc + 10;
                  addr3 = addr_inc + 20;
                  addr4 = addr_inc + 30;
                  addr5 = addr_inc + 40;
                  addr6 = addr_inc + 50;

                  TRACE_INT(addr1);
                  TRACE_INT(addr2);
                  TRACE_INT(addr3);
                  TRACE_INT(addr4);
                  TRACE_INT(addr5);
                  TRACE_INT(addr6);
                  TRACE_INT(addr_inc);
                  }
               break;
            case GO_UP      :
               if( (addr_inc != 0) )
                  {
                  TRACE_STR("decrementing address");
                  addr_inc = addr_inc - ADDRESS_INCREMENT;
                  addr1 = addr_inc  ;
                  addr2 = addr_inc + 10 ;
                  addr3 = addr_inc + 20 ;
                  addr4 = addr_inc + 30 ;
                  addr5 = addr_inc + 40 ;
                  addr6 = addr_inc + 50 ;
                  TRACE_INT(addr1);
                  TRACE_INT(addr2);
                  TRACE_INT(addr3);
                  TRACE_INT(addr4);
                  TRACE_INT(addr5);
                  TRACE_INT(addr6);
                  TRACE_INT(addr_inc);
                  }

               break;
            case SINGLE_STEP:
               ss_processor();
               break;
            case RESET_IP   :
               ip = 0;
               break;
            case END_PROG   :
               done = TRUE;
               break;
            }

         }

	   sed_Close(proc1_sed);
      disp_Close();
/*    while ( ss_processor() != BAD_CMD_FETCH ); */
      /*entry of data */
      /* single step run. */

#ifdef DEBUGGING
      fclose(trcfile);
      }
#endif
   }


unsigned int ss_processor()
   {
   char num_ary[12];
   unsigned int 
      tmp,
      ret_code,
      curr_cmd,
      new_ip;
   
   ret_code = 0;
   strcpy((char *)cmd_msg,"");
   switch(the_memory[ip])
      {
      case ADDR_TO_A      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"] -> A");

         a = the_memory[tar];
         new_ip = ip+2;
         break;
      case A_TO_ADDR      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move A -> [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"]");
         
         the_memory[tar] = a;
         new_ip = ip+2;
         break;
      case ADDR_TO_B      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"] -> B");
         
         b = the_memory[tar];

         new_ip = ip+2;
         break;
      case B_TO_ADDR      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);
         
         strcat((char *)cmd_msg,"Move B -> [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"]");

         the_memory[tar] = b;

         new_ip = ip+2;
         break;
      case ADDR_TO_C      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);
         
         strcat((char *)cmd_msg,"Move [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"] -> C");

         c = the_memory[tar];

         new_ip = ip+2;
         break;
      case C_TO_ADDR      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move C -> [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"]");
         
         the_memory[tar] = c;

         new_ip = ip+2;
         break;
      case ADDR_TO_D      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"] -> D");
         
         d = the_memory[tar];

         new_ip = ip+2;
         break;
      case D_TO_ADDR      :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Move D -> [");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg,"]");
         
         the_memory[tar] = d;

         new_ip = ip+2;
         break;
      case A_PLUS_B_TO_C  :
         c=a+b;

         strcat((char *)cmd_msg,"A+B -> C");

         new_ip = ip+1;
         break;
      case A_PLUS_C_TO_B  :
         b=a+c;
         
         strcat((char *)cmd_msg,"A+C -> B");

         new_ip = ip+1;
         break;
      case C_PLUS_B_TO_A  :
         a=c+b;
         
         strcat((char *)cmd_msg,"C+B -> A");

         new_ip = ip+1;
         break;

      case NUMBER_TO_A    :
         a=the_memory[ip+1];
         itoa(a,num_ary,10);

         strcat((char *)cmd_msg,"Move #");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg," -> A");
         
         new_ip = ip+2;
         break;
      case NUMBER_TO_B    :
         b = the_memory[ip+1];
         itoa(b,num_ary,10);

         strcat((char *)cmd_msg,"Move #");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg," -> B");

         new_ip = ip+2;
         break;
      case NUMBER_TO_C    :
         c = the_memory[ip+1];
         itoa(c,num_ary,10);

         strcat((char *)cmd_msg,"Move #");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg," -> C");

         new_ip = ip+2;
         break;
      case NUMBER_TO_D    :
         d = the_memory[ip+1];
         itoa(d,num_ary,10);

         strcat((char *)cmd_msg,"Move #");
         strcat((char *)cmd_msg,num_ary);
         strcat((char *)cmd_msg," -> D");

         new_ip = ip+2;
         break;
      case JUMP_TO_ADDR   :
         tar = the_memory[ip+1];
         itoa(tar,num_ary,10);

         strcat((char *)cmd_msg,"Jump ");
         strcat((char *)cmd_msg,num_ary);

         new_ip=tar;
         break;            

      case CALL           :
         tar = the_memory[ip+1];
         if (return_stack_top < (RETURN_STACK_SZ-1))
            {
            itoa(tar,num_ary,10);
            strcat((char *)cmd_msg,"Call ");
            strcat((char *)cmd_msg,num_ary);
            new_ip=tar;
            return_stack[return_stack_top] = ip+2;
            return_stack_top++;
            }
         else
            {
            strcat((char *)cmd_msg,"Return stack overflow");
            }
         break;

      case RETURN         :
         if (return_stack_top > 0)
            {
            return_stack_top--;
            tar = return_stack[return_stack_top];
            itoa(tar,num_ary,10);
            strcat((char *)cmd_msg,"Return to ");
            strcat((char *)cmd_msg,num_ary);
            new_ip=tar;
            }
         else
            {
            strcat((char *)cmd_msg,"Return stack underflow");
            }
         break;
      case CMP_A_B        :
         strcat((char *)cmd_msg,"cmp A,B");
         if (a<b)
            {
            zerof = OFF;
            carryf = ON;
            }
         else
            {
            if(a>b)
               {
               zerof = OFF;
               carryf = OFF;
               }
            if(a==b)
               {
               zerof = ON;
               carryf = OFF;
               }    
            }
         new_ip = ip+1;
         break;

      case CMP_A_C        :
         strcat((char *)cmd_msg,"cmp A,C");
         if (a<c)
            {
            zerof = OFF;
            carryf = ON;
            }
         else
            {
            if(a>c)
               {
               zerof = OFF;
               carryf = OFF;
               }
            if(a==c)
               {
               zerof = ON;
               carryf = OFF;
               }    
            }
         new_ip = ip+1;
         break;
      case BRANCH_LSS :
         strcat((char *)cmd_msg,"brlss");
         tar = the_memory[ip+1];

         if ((carryf==ON) && (zerof==OFF))
            {
            new_ip = tar;
            }
         else
            {
            new_ip = ip+2;
            }
         break;

      case BRANCH_GTR :
         strcat((char *)cmd_msg,"brgtr");
         tar = the_memory[ip+1];

         if ((carryf==OFF) && (zerof==OFF))
            {
            new_ip = tar;
            }
         else
            {
            new_ip = ip+2;
            }
         break;

      case BRANCH_EQL :
         strcat((char *)cmd_msg,"breql");
         tar = the_memory[ip+1];
         if (zerof==ON)
            {
            new_ip = tar;
            }
         else
            {
            new_ip = ip+2;
            }
         break;

      case BRANCH_LEQ :
         strcat((char *)cmd_msg,"brleq");
         tar = the_memory[ip+1];

         if (  ( carryf==ON                    ) || 
               ( (carryf==OFF) && (zerof==ON)  )    )
            {
            new_ip = tar;
            }
         else
            {
            new_ip = ip+2;
            }
         break;

      case BRANCH_GEQ :
         strcat((char *)cmd_msg,"brgeq");
         tar = the_memory[ip+1];
         if (carryf==OFF)
            {
            new_ip = tar;
            }
         else
            {
            new_ip = ip+2;
            }
         break;
      case A_MINUS_B_TO_C:
         c=a-b;

         strcat((char *)cmd_msg,"A-B -> C");

         new_ip = ip+1;
         break;
      case A_MINUS_C_TO_B:
         b=a-c;
         
         strcat((char *)cmd_msg,"A-C -> B");

         new_ip = ip+1;
         break;
      case C_MINUS_B_TO_A:
         a=c-b;
         
         strcat((char *)cmd_msg,"C-B -> A");

         new_ip = ip+1;
         break;
      case A_TO_ADDRINB  :
         if (b >= THE_MEMORY_SZ)
            {
            strcat((char *)cmd_msg,"bad memory offset");
            }
         else
            {
            strcat((char *)cmd_msg,"A -> [B]");
            the_memory[b] = a;
            }
         new_ip = ip+1;
         break;
      case ADDRINB_TO_A  :
         if (b >= THE_MEMORY_SZ)
            {
            strcat((char *)cmd_msg,"bad memory offset");
            }
         else
            {
            strcat((char *)cmd_msg,"[B] -> A");
            a = the_memory[b];
            }
         new_ip = ip+1;
         break;

      case SWAP_A_B :
         tmp = a;
         a = b;
         b = tmp;
         strcat((char *)cmd_msg,"A <-> B");
         new_ip = ip+1;
         break;
      case SWAP_A_C :
         tmp = a;
         a = c;
         c = tmp;
         strcat((char *)cmd_msg,"A <-> C");
         new_ip = ip+1;
         break;
      case SWAP_A_D :
         tmp = a;
         a = d;
         d = tmp;
         strcat((char *)cmd_msg,"A <-> D");
         new_ip = ip+1;
         break;
      case SWAP_B_C :
         tmp = b;
         b = c;
         c = tmp;
         strcat((char *)cmd_msg,"B <-> C");
         new_ip = ip+1;
         break;
      case SWAP_B_D :
         tmp = b;
         b = d;
         d = tmp;
         strcat((char *)cmd_msg,"B <-> D");
         new_ip = ip+1;
         break;
      case SWAP_C_D :
         tmp = c;
         c = d;
         d = tmp;
         strcat((char *)cmd_msg,"C <-> D");
         new_ip = ip+1;
         break;

      case ABORT          :
      default:
         strcat((char *)cmd_msg,"??? ");
         ret_code = BAD_CMD_FETCH;
         new_ip = ip;
      }
   ip = new_ip;
   return(ret_code);
   }

